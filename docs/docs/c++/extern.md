# extern in C++
###### Latest edited: Sep 20, 2023
***
### extern variable
```
// externTest.h
#ifndef EXTERNTEST_H
#define EXTERNTEST_H

extern int var;
void func();

#endif
```
```
// externTest.cpp
#include "externTest.h"
#include <iostream>

int var = 1;
void func() { std::cout << "func(): " << var << std::endl; }
```
```
// main.cpp
#include <iostream>
#include "externTest.h"

int main(){
    std::cout << "var in main: " << var << std::endl;
    func();
    var = 2;
    std::cout << "var in main: " << var << std::endl;
    func();
    return 0;
}
```
**Program output:**
```
var in main: 1
func(): 1
var in main: 2
func(): 2
```
**extern** keyword is usually used in header file to declare a variable or function that is defined in another file. In the above example, **var** is said as **extern** in ***externTest.h***, which is actually defined in ***externTest.cpp***. 
We can also observe that the value of **var** is changed in ***main.cpp***, which is reflected in ***externTest.cpp*** as well. This is because **var** is a global variable, which is shared by all the files that include ***externTest.h***.(a little bit like **static** variable)
- notice that **var** is not allocated any memory in ***externTest.h***, it is only declared as **extern**. The memory is allocated in ***externTest.cpp***.
- **extern** variable can only be defined once in a program.
- **static** is acutally on the opposite side of **extern**.:joy:**static** variable or function can be only used in the module where it is declared.

### extern function
```
// externFunc.cpp
int add(int a, int b){
    return a+b;
}
```
```
// externFuncTest.cpp
#include <iostream>
extern int add(int a, int b);

int main(){
    std::cout << add(1, 2) << std::endl;
    return 0;
}
```
**Program output:**
```3```
- **extern** function is used when a module is using functions from other module without including the corresponding header files.

### extern "C"
**extern "C"** is for using C code in C++.
Let's say this is a signature of a function:

```
void foo(int x, int y);
 ```
For a compiler of ***C++***, an **OOP** language which allows **function overloading**, the symbol of the function generated after compiled is slightly different from what a ***C*** compiler does:
```
_foo_int_int    // symbol generated by C++ compiler
_foo            // symbol generated by C compiler
```
Let's see how the linking process works without extern "C":
```
// moduleA.h
#ifndef MODULE_A_H
#define MODULE_A_H
int foo( int x, int y );
#endif
```
```
// moduleB.cpp
#include "moduleA.h"
foo(2,3);
```
In fact, at the linking stage, linker will try to look for **_foo_int_int** symbol from ***moduleA.o***!
If B is a **C** module, and A is a **C++** module, then the linker will not be able to find the symbol. Vice versa.
To solve this problem, we can use **extern "C"**:
```
// moduleA.h
#ifndef MODULE_A_H
#define MODULE_A_H
extern "C" int foo( int x, int y );
#endif
```
ModuleB remains the same. Now the linker will look for **_foo** symbol from ***moduleA.o***, which is generated by the ***C*** compiler.
- In short, **extern "C"** forces the function to be complied by a ***C*** compiler, which generates a ***C*** symbol for the function.

### C++ using C functions example
```
// cExample.h
#ifndef C_EXAMPLE_H
#define C_EXAMPLE_H
extern int add(int x,int y);
#endif
```
```
cExample.c
#include "cExample.h"
int add( int x, int y )
{
    return x + y;
}
```
```
// C++ file: cppFile.cpp
extern "C"
{
    #include "cExample.h"
}
int main(int argc, char* argv[])
{
    add(2,3);
    return 0;
}
```
```
// cppExample.h
#ifndef CPP_EXAMPLE_H
#define CPP_EXAMPLE_H
extern "C" int add( int x, int y );
#endif
```
```
// cppExample.cpp
#include "cppExample.h"
int add( int x, int y )
{
    return x + y;
}
```
```
/* cFile.c
/* Error ifï¼š#include "cExample.h", because there is no extern "C" in C */
extern int add( int x, int y ); // just like what we do with normal extern function

int main( int argc, char* argv[] )
{
    add( 2, 3 );   
    return 0;
}
```